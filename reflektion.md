# Reflektion

## Tabell - Kapitel 2 - Meaningful Names
Utvalda identifierare i det publika interfacet

| Namn och förklaring | Reflektion och regler från Clean Code |
|------|---------|
|**changeBackgroundColor(color)** Metodnamn på metod som ändrar diagrammets bakgrundsfärg|**Method Names** Använder ett verb, ”change”, för att visa att vi ändrar något - att det är metodens intention. **Use Intention-Revealing names** Metodnamnet tydligt avslöjar vår intention, nämligen att ändra bakgrundsfärgen|
|**resize(width, height)** Metodnamn på metod som ändrar storlek på canvas elementet|**Use Meaningful Distinctions** Metodnamnet är tydligt gällande vad det ska göra - ändra storlek, men det är inte tydligt vad som ska ändra storlek. Eftersom modulen bygger stapeldiagram så skulle ”resize” kunna innebära att ändra storlek på vilken del av diagrammet som helst. Vi skulle behöva vara tydligare och metodnamnet skulle bättre förklara sig själv om det hette resizeCanvas.|
|**addHeadline(text)** Metodnamn på metod som adderar en rubrik till diagrammet|**Don’t Add Gratuitous Context** Metodnamnet är kort och beskrivande, och det följer principen om att inte lägga till onödig kontext. Det ger information om att en rubrik läggs till. s. 30: ”Shorter names are generally better than longer ones, so long as they are clear. Add no more context to a name than necessary”|
|**addTotalVotes()** Metodnamn på metod som får diagrammet att visa antalet totala ”röster”|**Avoid disinformation** Metodnamnet är något missvisande eftersom den inte klart anger vad den gör för användaren. Metoden gör så att antalet ”röster” visas intill stapeldiagrammet. Metoden tar inga argument, vilket ”add” hade kunnat antyda på - att som användare av metoden ska jag addera någonting. viewTotalVotes() hade varit ett tydligare namn. **One Word Per Concept** Eftersom det redan finns en metod addHeadline() som tar en sträng som argument och adderar denna till canvasen, bör metoden addTotalVotes() inte ha samma prefix "add". Det skulle undvika förväxling mellan olika koncept. **Avoid Mental Mapping** Även om en programmerare kan förstå vad metoden gör, skulle det vara mer beskrivande att använda namnet viewTotalVotes() för att undvika att användaren behöver tolka vad metoden gör.|
|**PollDisplay** Klassnamn på den enda klassen för modulen|**Class names** ska vara ett substantiv (är det) som beskriver klassen. Klassen visar ett stapeldiagram.|

## Reflektion - Kapitel 2
Jag kan inte hitta något i detta kapitel som jag inte håller med om. Jag tycker att samtliga regler har en poäng som jag förstår syftet med. Jag tycker att avsnittet om ’avoid mental mapping’ är särskilt intressant just för att det framgår vikten av att koden inte bara ska gå att förstå, för det gör den oftast, men hur vi skriver den så att vi kan förstå den mer effektivt. Att behöva översätta variabelnamn i huvudet eller förstå dem på nytt förlänger och försvårar processen med att läsa eller skriva kod generellt.

## Tabell - Kapitel 3 - Functions
De fem längsta metoderna (både publika och privata)

| Namn och förklaring | Reflektion och regler från Clean Code |
|------|---------|
|**addPollValues(data)** Metod som tar in en array av värden och räknar förekomsten av respektive värde|**Do one thing** Denna metod har många olika sektioner (**sections with functions**) vilket är ett tecken på att den gör mer än en sak. Vi har felhantering, variabeldeklaration, nästlade kontrollsatser och metodanrop. **Have no side effects** Metoden uppdaterar hela diagrammet om nya värden skickas in i ett nytt metodanrop, vilket kan vara oväntat. Det bryter mot principen om att funktionen inte ska ha dolda biverkningar.|
|**#addBackgroundCounter()** Privat metod som visar linjer som representerar y-värdena i diagrammets bakgrund|**Blocks and Indenting** Metoden innehåller en for-loop med flera (8) rader kod. Koden bör brytas ut i mindre funktioner. Boken menar att kontrollsatser helst ska innehålla en rad kod, antagligen ett metodanrop. **Use Descriptive Names** Metoden bör ha ett mer beskrivande namn som tydligt menar att den ritar upp linjer i bakgrunden av diagrammet. T.ex #drawBackgroundLines().|
|**addHeadline(text)** Metod som adderar en rubrik till diagrammet|**Error Handling** Metoden tar argument i form av en sträng. Metoden vailderar argumentet och har felhantering. Felhanteringen bör vara i en egen funktion, då en funktion vars uppgift är felhantering ska inte hantera någonting annat. **Don’t Repeat Yourself** Metoderna addHeadline och addBackgroundCounter har delvis likadan kod, med syfte att addera text till en viss position. Detta hade med fördel brytits ut till en egen funktion och istället anropats.|
|**#addExistingValues()** Privat metod som adderar befintlig data till diagrammet - om det finns|**Do One Thing** Metoden lägger till redan befintlig data till diagrammet. Dock har den if-satser, ser om datan finns för att i så fall göra metodanrop. Detta är egentligen flera uppgifter. **One Level of Abstraction** Metoden är konsekvent i vad den gör, på vilken detaljnivå den jobbar. Metoden tittar efter värden, och finns värden så adderar den värden till befintlig canvas.|
|**#buildPolls()** Privat metod som räknar ut var respektive stapel ska placeras på diagrammet samt itererar igenom x-värdena för att bygga upp varje stapel|**Blocks and Indenting** och **Do One Thing** Denna metod har en for loop med många rader kod i sig. För varje iteration ritas en stapel upp (via anrop till en annan metod) samt adderar en text in till stapeln. Funktionaliteten för att addera texten bör vara en egen metod. **Function Arguments / Triads** Om funktionaliteten nämnd ovan var i en egen metod skulle den ta in tre argument (bli en ’**triad**’), vilket gör koden mer komplex och mindre läsbar. Funktionen skulle ta in ett x-värde, ett y-värde och en textsträng. Jag hade ändå föredragit att bryta ut funktionaliteten, eftersom x och y värdena tillsammans bildar en position och är såpass grundläggande koncept anser jag att det är ett tillfälle där en ’triad’ är OK.|


## Reflektion - Kapitel 3
Jag tycker att principen ’Do One Thing’ är en tydlig och mätbar riktlinje. Jag kan faktiskt se vad min funktion gör, hur många uppgifter den har och vad den bör göra - det går att se funktionaliteten på ett sätt som jag inte på samma självklara sätt kan se för principer vid t.ex namngivning. Att välja ett beskrivande metodnamn enligt principerna som tas upp i boken verkar delvis enkelt men också svårt. Jag håller med om att ett metodnamn gärna får vara långt. Jag förstår att ord som inte fyller en funktion för sammanhanget inte bör inkluderas, men när är långt för långt och när är långt bra långt? När förtydligar någonting kontexten och när behövs det inte? Vid val av metodnamn ställs vi inför beslut som ska tas utifrån vad som ses som rimligt - Men en spretig funktion säger snarare till mig att den gör för mycket. Jag ser dock att en stor del av poängen med dessa förhållningssätt är inte att vår namngivning ska vara ”korrekt”, men att jag ens reflekterar över vad mitt metodnamn antyder - kommer antagligen göra det lättare att förstå den.


## Reflektion - egna erfarenheter från egen kodkvalitet
Det har varit intressant att reflektera över vilka regler jag anser att jag naturligt följer och vilka jag behöver aktivt anpassa mig till för att skriva min kod mer i enlighet med bokens riktlinjer. Problemen nämnda i tabellerna ovan är inte åtgärdade, men problem med min kodkvalitet fanns i mycket större utsträckning innan jag började analysera och leta efter dem. Jag hittade många fall där jag bröt mot principen ’Do One Thing’. När min kod först fungerade som jag ville, likadant som den fungerar vid inlämning, hade jag nog hälften så många metoder än vad jag slutligen har. Jag samlade mycket spretig funktionalitet, som berör samma problem, i en och samma metod och behövde anstränga mig för att bryta isär den. 
              
Jag har märkt att jag intuitivt tänker på att inte namnge variabler med enstaka bokstäver eller förkortningar. Jag tror att det som faller sig naturligt att skriva utifrån det man själv förstår och föredrar när man skriver sin kod. Jag upplever att det tar mig längre tid att komma framåt om jag inte namnger variabler på ett tydligt sätt som talar om för mig vad variabeln representerar (undviker mental mapping). Vad som däremot är viktigt för kodkvaliteten är att namngivningen inte ska vara begriplig enbart för mig själv.
                 
Ännu en brist i min kodkvalitet är att jag använder liknande namn för metoder som har olika syften, vilket går emot principen ’one word per concept’. Det blir tydligt att jag inte har gjort tillräckliga distinktioner mellan dem. Ett exempel på detta är att jag har en privat metod i klassen som heter #clearHeadline och en publik metod som heter removeHeadline. Problemet är att dessa namn inte tydligt markerar skillnaden mellan metoderna eller förklarar varför man skulle använda den ena framför den andra. Prefixen "clear" och "remove" kan tolkas som synonymer inom denna kontext, och min nuvarande namngivning misslyckas med att klart kommunicera vad respektive metod faktiskt gör.